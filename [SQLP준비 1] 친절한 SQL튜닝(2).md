# 4 조인 튜닝

## 4.1 NL 조인

조인의 기본

### 4.1.1 기본 메커니즘

`사원`테이블에서 1996년 이후 입사한 직원을 찾고
`고객`테이블에서 그 사원이 관리하는 고객을 찾는 쿼리가 있을 때

- 절차 > 사원을 찾고 그에 해당하는 고객을 건건이 찾는다. → NL조인의 방식
2중 반복문과 같은 원리


- 이 때 사원이 `outer`쪽이고, 고객이 `inner`쪽이다.
- 기본적으로 NL조인은 양쪽 테이블의 인덱스를 사용하지만,
outer쪽 테이블이 크지 않다면 인덱스를 사용하지 않을 수 있다.

### 4.1.2 NL조인 실행계획 제어

```sql
-- ordered 힌트는 FROM절에 기술한 순서대로 조인 수행하라는 지시
select /*+ ordered use_nl(c) */ * 
from e, c

-- 여러 테이블을 조인 할 경우
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ * 
from A, B, C, D

-- ordered 대신 leading 활용
select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hash(B) */ * 

-- ordered/leading 없이 사용 : 옵티마이저가 스스로 정함
select /*+ use_nl(A, B, C, D) */ * 
```

### 4.1.3 NL 조인 수행 과정 분석

** 262p NL조인 순서 분석 맞춰보기**

- NL조인은 각 단계를 완전히 끝낼때마다 넘어가는 것이 아니라
조건이 일치할 때 마다 다음 절차를 진행한다.(이중 반복, DFS와 동일)


### 4.1.4 NL 조인 튜닝 포인트

그림 4-7에서의 튜닝 포인트

1. 사원_X1인덱스를 읽고 사원 테이블을 액세스하는 부분
   - 필터링되는 비율이 높다면 부서코드를 인덱스에 추가하는 것을 고려할 만 하다.


2. 고객_X1를 탐색하는 부분
   - 어쩌라고?


3. 고객_X1 인덱스를 읽고 고객 테이블을 액세스 하는 부분
   - 여기서도 필터링 비율이 높다면 고객_X1 인덱스에 최종주문 금액 컬럼을 추가하는 방안 고려
   
   
그리고 기본적으로 사원_X1 인덱스에서 얻은 건수에 따라 전체 일량이 좌우됨

기본적 튜닝 방법으론 각 단계의 일량을 분석하고, 과도한 랜덤 액세스가 발생하는 지점을 파악한다.
그 후 조인 순서를 변경하거나 인덱스 변경/교체를 검토, 인덱스 추가/구성변경도 검토

최종적으로 성능향상요소를 찾기 어렵다면 `소트 머지 조인`/`해시 조인`을 검토


### 4.1.5 NL 조인 특징 요약
- 랜덤 액세스 위주의 조인 방식
  - 대량 데이터 조인에 불리함


- 한 레코드씩 순차적으로 진행
  - 대량 데이터 조인에는 불리하지만, 응답속도에서는 매우 빠름(부분 범위 처리 가능할 시)
  

- 먼저 액세스 되는 테이블의 범위에 따라 전체 일량이 결정됨

- 인덱스 구성 전략이 특히 중요


**→ 전체적으로 소량 데이터 혹은 부분 범위 처리에 특화된 조인**


### 4.1.6 NL 조인 튜닝 실습

- 첫 예시 쿼리의 실행계획을 통해 부하 지점 파악하기

- `cr` : consistent read, 읽은 블록 수, 버퍼 캐시에서 읽음
- `pr` : physical read, 디스크에서 읽어서 버퍼 캐시에 적재

- 두, 세번째 예시도 파악하기


### 4.1.7 NL 조인 확장 메커니즘

- Prefetch : 인덱스를 이용해 액세스하다가 디스크IO가 필요해지면 이어서 읽을 블록들도 미리 읽어오는 기능
  - 발동 시 실행계획 : 고전적인 Nested Loop에서 (최하단의) Table Access 계획이 최상단으로 올라가는 형태


- 배치 IO : 디스크IO를 쌓아뒀다가 한번에 처리
  - 발동 시 실행계획 : 고전적인 Nested Loop에서 (최하단의) Table Access 계획이 최하단에서 밖으로 나오는 형태, 최상단에 이를 감싸는 Nested Loops 문구 추가됨


배치IO가 발동할 시에는 데이터 정렬 순서도 바뀔 수 있다.
따라서 소트생략/부분범위 처리 등을 위해 배치IO가 발동하지 않길 원한다면 no_nlj_batching(b) 같은 힌트를 추가해야함



## 4.2 소트 머지 조인

인덱스가 없거나 대량 데이터 조인이라 인덱스의 효과가 없을 때
옵티마이저는 `소트 머지 조인` / `해쉬 조인`을 사용함


### 4.2.1 SGA vs PGA
- SGA : 여러 프로세스가 공유, 동시 액세스는 불가
  - 직렬화를 위한 락매커니즘 > Latch
  - 핵심 구성요소 : DB 버퍼캐시
- PGA : 프로세스의 고유 메모리 영역
  - PGA공간이 작을 때 > Temp Tablespace 사용
  - Latch 메커니즘 불필요 → 버퍼캐시에서 읽을 때 보다 빠름

### 4.2.2 기본 메커니즘
- 소트 머지 조인
  1. 소트 단계
     - 조인 컬럼 기준으로 정렬
  2. 머지 단계
     - 정렬한 집합을 Merge

- 4.1에서 사용했던 쿼리로 설명
  1. 사원 테이블의 결과집합을 정렬하여 `PGA`의 `Sort Area`에 저장, 공간 부족 할 시 `Temp Tablespace`에 저장
  2. 고객 테이블의 결과집합을 마찬가지로 정렬하여 저장

즉 조인컬럼 기준으로 정렬한 자체를 인덱스로 삼음


### 4.2.3 소트 머지 조인이 빠른 이유

- NL조인은 인덱스를 이용하기 때문에, 액세스하는 모든 블록을 랜덤 액세스 방식으로 DB 버퍼캐시를 경유해서 읽음.
  - 추가적인 `래치 경쟁`과 `캐시버퍼 체인 스캔` 과정을 거침. 버퍼캐시에서 못 찾을 경우 `DISK IO`도 발생


- 소트 머지 조인은 PGA에서 수행하므로 래치경쟁에서 비교적 자유로움
  - 소트 머지 조인도 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유하고, 인덱스를 사용하기도 함.
  이때는 버퍼캐시 탐색 비용, 랜덤 액세스 비용을 피할 수 없음


### 4.2.4 소트 머지 조인의 주 용도

- 조인 조건이 `=` 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 카테시안(크로스) 조인


### 4.2.5 소트 머지 조인 제어하기

`SELECT /*+ ordered use_merge(c) *`


### 4.2.6 소트 머지 조인 특징 요약
소트 부하만 감수하면, 건건이 버퍼캐시를 경유하는 NL조인보다 빠르다
NL조인과 달리 인덱스 유무의 영향을 받지 않는다.

> 250217(월) 255p ~ 281p

## 4.3 해시 조인

`소트 머지 조인`과 `해시조인`은 인덱스가 필수적이지 않음
→ 대량 데이터 조인에 NL조인보다 빠르고, 일정한 성능을 보임 

해시조인은 테이블을 정렬하는 부하도 없음

### 4.3.1 기본 메커니즘

다른 조인과 마찬가지로 두 단계로 진행됨
(NL 조인 → outer에서 해당하는 로우를 찾고, inner에서 해당하는 로우를 건건히 찾음 (2중반복문)
소트머지조인 → 소트 단계; 조인 컬럼 기준으로 양쪾 테이블 정렬, 머지 단계; 정렬한 집합을 병합)

1. Build 단계
   - 작은 쪽 테이블 (Build Input)을 읽어 헤시 테이블(해시 맵)을 생성한다.
   - ex) 사원번호로 PGA의 Hash Area 혹은 Temp Tablespace에 해시 테이블을 생성
2. Probe 단계
   - 큰 쪽 테이블 (Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.
   - ex) 최종주문금액 조건을 만족하는 로우 중에서 관리사원번호로 해쉬조인을 실시한다.

힌트 : `use_hash(a b)`


### 4.3.2 해시 조인이 빠른 이유

소트 머지 조인이 빠른 이유와 같음
- PGA에서 진행, 래치 경쟁 X

해시조인도 Build Input, Probe Input을 각 테이블에서 읽을 때는 DB 버퍼캐시를 경유하고, 인덱스를 사용하기도 한다.

- 해시테이블에는 조인 키값만이 아닌 쿼리에 사용되는 모든 컬럼이 포함된다.


- 소트 머지 조인의 준비 단계 : 양 테이블을 조인 키 값으로 정렬. 이 때 Temp Tablespace로 넘어갈 가능성이 높음
- 해시 조인의 준비 단계 : 작은 쪽 테이블을 읽어서 해시 테이블 생성. Temp Tablespace로 넘어가더라도 상대적으로 부하 적음
  - Temp Tablespace로 넘어가지 않고 PGA의 해시 공간에서 처리하는 것을 `인메모리 해시 조인`이라 칭함


### 4.3.3 대용량 Build Input 처리

양 쪽 테이블이 모두 대용량이라 인메모리 해시 조인이 불가능하다면
→ 분할 정복방식을 사용

1. 파티션 단계
   - 양쪽 집합 **(조인 이외 조건절을 만족하는 레코드)** 의 조인컬럼으로 얻은 해시값들을 바탕으로 동적으로 파티셔닝
     - 독립적으로 처리 가능한 여러 서브집합으로 짝이 맞게 분할
   - Temp Tablespace에 저장

2. 조인 단계
   - 각 짝으로 조인 수행
     - 이 때 테이블에 상관없이 작은 쪽이 Build Input, 큰 쪽이 Probe Input
     - Build Input으로 해시 테이블을 만들고, 반대쪽으로 해시테이블 탐색
     
     
### 4.3.4 해시 조인 실행계획 제어

힌트에 ordered없이 use_hash만 사용할 경우 옵티마이저는 조건절에 해당하는 카디널리티가 작은 테이블을 Build Input으로 선택한다.

Build Input을 지정하고 싶다면 ordered 혹은 leading절을 이용한다.
`swap_join_inputs(t)` 구문으로 직접 지정할 수도 있다.

```sql
select /*+ leading(a) use_hash(b) swap_join_inputs(b) */
```


#### 세 개 이상 테이블 해시 조인

- `swap_join_inputs`, `no_swap_join_inputs` 힌트를 이용해 Build Input을 지정하는 방법 기억하기
- 원하는 조인 순서에 따라 leading 힌트에 기술하고, Build Input으로 사용하고 싶은 테이블을 swap_join_inputs에 지정하면 된다.
  - 조인된 결과 집합을 Build Input으로 지정하고 싶다면 `no_swap_join_inputs`로 Probe Input을 지정하면 된다.
  
  
### 4.3.5 조인 메소드 선택 기준

- 일반적인 메소드 선택 기준
  1. 소량 데이터 조인 → NL조인
  2. 대량 데이터 조인 → 해시 조인
  3. 해시조인이 불가능 할 때 (`=`조건으로 조인하지 않을 때) → 소트 머지 조인


- 대량의 기준 : NL조인 기준으로 최적화했음에도 랜덤 액세스가 많고 성능이 문제라면 대량

- 해시조인이 매우 빠른 경우가 아니라면 NL조인이 바람직하다.

- 조인방식을 고를 때 NL조인을 먼저 고려해야하는 이유
  - 수행빈도가 높은 쿼리를 해시조인, 소트 머지 조인으로 처리하면 CPU와 메모리에 부담이 너무 커짐


## 4.4 서브쿼리 조인

실무에서는 두세개가 아닌 더 많은 테이블을 조인하기 때문에
서브쿼리 조인에 대한 이해가 있어야 한다.

### 4.4.1 서브 쿼리 변환이 필요한 이유

옵티마이저는 비용을 산출하기 전에
사용자가 제출한 쿼리를 최적화하기 쉽도록 변환

- 서브 쿼리 종류
  - 인라인 뷰
  - 중첩 서브쿼리
  - 스칼라 서브쿼리

### 4.4.2 서브쿼리와 조인

#### 필터 오퍼레이션

- exists에 사용한 서브쿼리문에 `/*+ no_unnest */` 기술하면 서브쿼리를 풀어내지 않음으로써 필터링을 위해 사용할 수 있다.

- NL조인과 필터 작동이 다른점
  - 스킵기능; 메인쿼리와 서브쿼리와 조인된 후에는 break; 서브쿼리의 다음을 계속 이행하지 않고, 메인쿼리의 다음 로우를 처리한다.
  - 캐싱기능; 서브쿼리에 입력하는 값에 따른 결과값을 캐싱하여 반복된 값에 대한 답을 바로 도출


- 서브쿼리는 항상 메인 쿼리에 종속됨. 메인쿼리가 드라이빙 집합


#### 서브쿼리 unnesting

계층구조를 풀어내고 flat하게 만들어줌

unnesting되면 `필터` 방식을 사용할순 없지만
조인문처럼 다양한 최적화 기법 사용 가능

- `nl 세미 조인` : nl조인과 같은 프로세스지만, 조인에 성공하면 진행을 멈추고 다음 메인 쿼리를 진행

이 외에도 다양한 기법이 활용될 수 있다는 장점

```sql
-- 서브쿼리를 메인쿼리보다 먼저 처리하게 힌트 기술
select /*+ leading(거래@subq) use_nl(c)*/ *
from table_c c
where exists (
	select /*+ qb_name(subq) unnest */ 'x'
    from 거래
    where c.col_a = 거래.col_a
    	and ~
)


-- unnset 후 hash 세미조인으로 처리하게 기술

select ~
from ~
where exists (
	select /*+ unnest hash_sj */ 'x'
    from ~
    where <조인문>
    	~
)
```

- `rownum<:n`으로 출력 수를 제한하는 방법을 서브쿼리에 사용하면 성능이 떨어질 수도 있다.
  - ex) exists에 사용하는 서브쿼리문에 rownum<=1 사용

rownum 조건은 여러 힌트를 작동하지 못하게함 (unnest 등)


#### 서브쿼리 pushing

일반적으로 unnest되지 않은 서브쿼리는 보통 필터 방식으로, 맨 마지막 순서로 처리됨

- 309p의 실행계획
  - 서브쿼리에서 필터링하는 데이터의 양이 상당하다.
  필터링을 먼저 하여 조인되는 양을 줄일 수 있다면 좋은 경우


- 서브쿼리 Pushing : 서브쿼리를 실행계획 안쪽으로 밀어넣음. 먼저 처리되게함. 
힌트 : `select /*+ no_unnest push_subq */ col_a, col_b`
  - **unnest되지 않은 서브쿼리에만 작동함**. 따라서 `no_unnest`와 같이 사용하는 것이 바람직
  

### 4.4.3 뷰(view)와 조인

- 최적화 단위는 기본적으로 쿼리 블록


- 311p 뷰와 조인하는 쿼리
  - 뷰 밖에선 전월 데이터만 읽는데, 뷰는 이미 모든 데이터를 읽는다.
  → `select /*+ merge */` 힌트를 이용해 메인 쿼리와 합침. 
  @ 이 때 변하는 실행계획 **확인하기** @
  
  - merge하여 수정된 내용으론 `nl join`방식을 사용하여 비효율은 줄었지만,
  전체를 group by 한 후 출력할 수 있기 때문에 부분범위 처리는 불가능하다.
  → 이런 경우 보통 `hash 조인`이 빠름

#### 조인 조건 pushdown

메인 쿼리의 조인 조건절 값을 뷰 안으로 밀어넣음
힌트 : `select /*+ no_merge push_pred */ col_a, col_b`

위 힌트를 써서 실행계획에 `VIEW PUSHED PREDICATE`가 발생한다면
기술된 쿼리의 같은 경우 당월 거래 데이터만 조회하고, 중간에 멈출 수도 있다. (부분범위 처리가 가능하다)

실행계획만 보면 고객데이터와 조인하기 전에 group by까지 수행한다.
조인조건이 pushdown됐으므로 `group by 조인조건`을 수행하여 부분범위처리가 가능한 것
`push down predicate` 라는 실행계획에 유의


- `Lateral`, `Outer apply`, `Cross Apply` 구문으로 인라인 뷰를 대체하면, 인라인 뷰에서 다른 테이블의 컬럼을 참조하고 조인할 수 있다. 
단 조인 조건 pushdown이 잘 작동하므로 대체할 정도는 아니고, 코드가 혼란해질 수 있다.

> 250218(화) 282p ~ 316p

### 4.4.4 스칼라 서브쿼리 조인

#### (1) 스칼라 서브쿼리의 특징

- PLSQL함수를 만들어서 select절에 사용하면 메인쿼리 건수만큼 '재귀적으로' 반복 실행됨
- 반면 스칼라 서브쿼리로 사용하면, 반복실행된다는 것은 맞지만 함수처럼 CTS를 유발하진 않음
  - 아래 sql은 아우터 조인처럼 수행된다는 것

```sql
select a, b, c, d
	, (select name from dept where dept.deptno = emp.deptno) dname
from emp
where ~

-- 위 쿼리는 아래처럼 아우터 조인처럼 수행됨


select /*+ ordered use_nl(d) */ a, b, c, d, dname
from emp, dept
where dept.deptno(+) = e.deptno
	and ~
```

차이점은 스칼라 서브쿼리는 캐싱 작용이 일어남.


#### (2) 스칼라 서브쿼리 캐싱 효과

스칼라 서브쿼리로 조인 시 입출력값이 캐싱됨
- 입력값 > 서브쿼리에서 참조하는 메인쿼리의 컬럼 값(조인컬럼)

이 캐싱효과를 이용하여 PLSQL함수에다 스칼라 쿼리를 덧씌워서 캐싱효과를 이끌어낼 수 있다.
ex) `select a, b, (select get_dname(emp.deptno) from dual) from emp where ~`


#### (3) 스칼라 서브쿼리 캐싱 부작용

반대로 입력값의 범위가 넓어서 캐싱효과를 거의 받지 못한다면 오히려 캐싱 확인으로 인한 부하만 증가한다.

또, 메인쿼리 집합의 크기가 작으면 캐시 재사용성이 떨어져서 성능에 악영향(캐시 영역에 저장만 하고 이용 X)


#### (4) 두 개 이상의 값 반환

스칼라 서브쿼리에서 여러 값을 뽑아내고 싶을 때

1. 스칼라 서브쿼리를 여러개 쓴다 → 비효율

2. 문자열 결합연산자를 이용해 묶어서 출력한 뒤 substring으로 빼낸다 → 비효율

3. OBJECT TYPE 사용 → 번거로움

4. 스칼라 서브쿼리 대신 인라인 뷰를 이용한다.
→ 인덱스 비효율이 있거나(no_merge), group by등으로 부분범위 불가(merge)등의 문제
→ 이럴 때 push_pred(조인 조건 푸시다운)이 유용


#### (5) 스칼라 서브쿼리 unnesting

스칼라 서브쿼리는 NL방식으로 조인되므로 캐싱효과가 미미하다면 랜덤IO 부담이 있다.
병렬 쿼리에선 특히 스칼라 서브쿼리를 사용하지 않아야함
대량 데이터를 처리하는 병렬 쿼리는 해시 조인으로 처리해야 효과적이기 때문
→ 서브쿼리 unnesting

unnesting되면 해시조인으로 처리 가능함


# 5장 소트 튜닝

## 5.1 소트 연산에 대한 이해

소팅, 해싱, 그룹핑에 PGA/Temp Tablespace를 사용함


### 5.1.1 소트 수행 과정

소팅 : 크기에 따라 두가지로 나뉨 - 메모리 / 디스크

- 디스크 소팅 과정
  - SGA 버퍼캐시 → PGA의 Sort Area → 양이 많을 경우 정렬된 중간집합은 Temp Tablespace에 저장(Sort run) → 반복
  - 정렬이 완료되면 템프 테이블스페이스의 소트 런들을 Merge (정렬된 순서대로 클라이언트로 전달)

→ 소팅은 메모리, CPU 부하를 일으키고, 양이 많으면 DISK IO까지 발생
부분 범위 처리도 할 수 없음.
피할 수 있으면 피하고, 피할 수 없다면 최대한 인메모리 소팅으로 진행되게 유도해야함


### 5.1.2 소트 오퍼레이션

소트를 발생시키는 오퍼레이션(실행계획)

#### (1) Sort Aggregate
- 전체 로우 대상으로 집계 수행 할 때 등장 (소팅은 아님)

실제로 정렬을 하진 않고 수학적 연산 수행(min max sum avg 등)
\> `sum` `count` `min` `max` 를 두고 값을 읽을 때마다 갱신해가는 연산과정 
→ 큰 sort area가 필요하지 않다. 

#### (2) sort order by
- 데이터 정렬 수행


5.1.1의 그림과 같은 과정 수행


#### (3) sort group by
- 그룹별 집계 수행


(1)처럼 갱신연산을 그룹마다 수행.
마찬가지로 큰 sort area가 필요하지 않다. (temp tablespace도 필요 없음)


- `hash group by`
: group by 절 후에 order by 절이 없으면 대부분 hash gorup by로 처리됨
group by 컬럼의 해시값으로 집계 항목 갱신


#### (4) sort unique

- Unnesting된 서브 쿼리가 M쪽 집합이거나 1쪽 집합이더라도 Unique 인덱스가 없으면,
메인 쿼리와 조인하기 전에 중복 레코드를 제거해야함.

- 만약 PK/Unique Constraint/Unique Index 속성이 있다면 Sort Unique 오퍼레이션은 생략됨

- 집합 연산자(union, minus, intersect)를 사용할 때도 위 실행계획이 나타남

- Distinct 연산에는 `Hash Unique` 방식이 등장 (order by 없을 때)


#### (5) Sort join
소트 머지 조인 수행 시 등장

#### (6) window sort
윈도우 함수 사용 시 등장

이로써 소트를 발생시키는 오퍼레이션 종류를 확인하였음.

## 5.2 소트가 발생하지 않도록 SQL 작성

### 5.2.1 Union vs Union ALL

중복제거연산이 필요한 게 아니라면 union all을 사용해야 sort unique 생략됨


```sql
-- 아래 쿼리는 중복 가능성 있음
select ~
from pay
where paydate = 20180316
UNION ---------------------
select ~
from order
where orderdate = 20180316


-- 아래와 같이 수정 가능
select ~
from pay
where paydate = 20180316
UNION ALL -----------------
select ~
from order
where orderdate = 20180316
	and paydate != 20180316
    
    
-- paydate가 nullable이면
select ~
from pay
where paydate = 20180316
UNION ALL -----------------
select ~
from order
where orderdate = 20180316
	and (paydate != 20180316 or paydate is null)
    -- 혹은 lnnvl(paydate = 20180316)
```

### 5.2.2 Exists 활용

- `distinct`는 전체 데이터를 읽고 중복을 비교해야해서 부하가 심함
  - `exists`문으로 대체할 수 있다.

→ 347p에서 바뀌는 쿼리 확인

- exists문은 1. 조인이 아니고, 2. 조건이 맞으면 다음 메인쿼리로 진행하기 때문에 중복데이터가 없다.
(단 exists문에 사용된 c의 정보를 출력하지 못함)


- `minus` 연산자는 `not exists`문으로 대체할 수 있다.


### 5.2.3 조인 방식 변경

인덱스가 적절히 있어도 hash join으로 진행되버리면 소트연산 생략 불가
→ 인덱스를 통해 NL조인 유도 `/*+ leading(t1) use_nl(t2)*/`

order by에 조인 컬럼으로 기술돼있으면 `use_merge(t2)`, 소트 머지 조인에서도 소트 생략 가능

> 250219(수) 317p ~ 349p

## 5.3 인덱스르 이용한 소트 연산 생략

> 250220(목) 350p ~ p

