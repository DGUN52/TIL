# 4 조인 튜닝

## 4.1 NL 조인

조인의 기본

### 4.1.1 기본 메커니즘

`사원`테이블에서 1996년 이후 입사한 직원을 찾고
`고객`테이블에서 그 사원이 관리하는 고객을 찾는 쿼리가 있을 때

- 절차 > 사원을 찾고 그에 해당하는 고객을 건건이 찾는다. → NL조인의 방식
2중 반복문과 같은 원리


- 이 때 사원이 `outer`쪽이고, 고객이 `inner`쪽이다.
- 기본적으로 NL조인은 양쪽 테이블의 인덱스를 사용하지만,
outer쪽 테이블이 크지 않다면 인덱스를 사용하지 않을 수 있다.

### 4.1.2 NL조인 실행계획 제어

```sql
-- ordered 힌트는 FROM절에 기술한 순서대로 조인 수행하라는 지시
select /*+ ordered use_nl(c) */ * 
from e, c

-- 여러 테이블을 조인 할 경우
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ * 
from A, B, C, D

-- ordered 대신 leading 활용
select /*+ leading(C, A, D, B) use_nl(A) use_nl(D) use_hash(B) */ * 

-- ordered/leading 없이 사용 : 옵티마이저가 스스로 정함
select /*+ use_nl(A, B, C, D) */ * 
```

### 4.1.3 NL 조인 수행 과정 분석

** 262p NL조인 순서 분석 맞춰보기**

- NL조인은 각 단계를 완전히 끝낼때마다 넘어가는 것이 아니라
조건이 일치할 때 마다 다음 절차를 진행한다.(이중 반복, DFS와 동일)


### 4.1.4 NL 조인 튜닝 포인트

그림 4-7에서의 튜닝 포인트

1. 사원_X1인덱스를 읽고 사원 테이블을 액세스하는 부분
   - 필터링되는 비율이 높다면 부서코드를 인덱스에 추가하는 것을 고려할 만 하다.


2. 고객_X1를 탐색하는 부분
   - 어쩌라고?


3. 고객_X1 인덱스를 읽고 고객 테이블을 액세스 하는 부분
   - 여기서도 필터링 비율이 높다면 고객_X1 인덱스에 최종주문 금액 컬럼을 추가하는 방안 고려
   
   
그리고 기본적으로 사원_X1 인덱스에서 얻은 건수에 따라 전체 일량이 좌우됨

기본적 튜닝 방법으론 각 단계의 일량을 분석하고, 과도한 랜덤 액세스가 발생하는 지점을 파악한다.
그 후 조인 순서를 변경하거나 인덱스 변경/교체를 검토, 인덱스 추가/구성변경도 검토

최종적으로 성능향상요소를 찾기 어렵다면 `소트 머지 조인`/`해시 조인`을 검토


### 4.1.5 NL 조인 특징 요약
- 랜덤 액세스 위주의 조인 방식
  - 대량 데이터 조인에 불리함


- 한 레코드씩 순차적으로 진행
  - 대량 데이터 조인에는 불리하지만, 응답속도에서는 매우 빠름(부분 범위 처리 가능할 시)
  

- 먼저 액세스 되는 테이블의 범위에 따라 전체 일량이 결정됨

- 인덱스 구성 전략이 특히 중요


**→ 전체적으로 소량 데이터 혹은 부분 범위 처리에 특화된 조인**


### 4.1.6 NL 조인 튜닝 실습

- 첫 예시 쿼리의 실행계획을 통해 부하 지점 파악하기

- `cr` : consistent read, 읽은 블록 수, 버퍼 캐시에서 읽음
- `pr` : physical read, 디스크에서 읽어서 버퍼 캐시에 적재

- 두, 세번째 예시도 파악하기


### 4.1.7 NL 조인 확장 메커니즘

- Prefetch : 인덱스를 이용해 액세스하다가 디스크IO가 필요해지면 이어서 읽을 블록들도 미리 읽어오는 기능
  - 발동 시 실행계획 : 고전적인 Nested Loop에서 (최하단의) Table Access 계획이 최상단으로 올라가는 형태


- 배치 IO : 디스크IO를 쌓아뒀다가 한번에 처리
  - 발동 시 실행계획 : 고전적인 Nested Loop에서 (최하단의) Table Access 계획이 최하단에서 밖으로 나오는 형태, 최상단에 이를 감싸는 Nested Loops 문구 추가됨


배치IO가 발동할 시에는 데이터 정렬 순서도 바뀔 수 있다.
따라서 소트생략/부분범위 처리 등을 위해 배치IO가 발동하지 않길 원한다면 no_nlj_batching(b) 같은 힌트를 추가해야함



## 4.2 소트 머지 조인

인덱스가 없거나 대량 데이터 조인이라 인덱스의 효과가 없을 때
옵티마이저는 `소트 머지 조인` / `해쉬 조인`을 사용함


### 4.2.1 SGA vs PGA
- SGA : 여러 프로세스가 공유, 동시 액세스는 불가
  - 직렬화를 위한 락매커니즘 > Latch
  - 핵심 구성요소 : DB 버퍼캐시
- PGA : 프로세스의 고유 메모리 영역
  - PGA공간이 작을 때 > Temp Tablespace 사용
  - Latch 메커니즘 불필요 → 버퍼캐시에서 읽을 때 보다 빠름

### 4.2.2 기본 메커니즘
- 소트 머지 조인
  1. 소트 단계
     - 조인 컬럼 기준으로 정렬
  2. 머지 단계
     - 정렬한 집합을 Merge

- 4.1에서 사용했던 쿼리로 설명
  1. 사원 테이블의 결과집합을 정렬하여 `PGA`의 `Sort Area`에 저장, 공간 부족 할 시 `Temp Tablespace`에 저장
  2. 고객 테이블의 결과집합을 마찬가지로 정렬하여 저장

즉 조인컬럼 기준으로 정렬한 자체를 인덱스로 삼음


### 4.2.3 소트 머지 조인이 빠른 이유

- NL조인은 인덱스를 이용하기 때문에, 액세스하는 모든 블록을 랜덤 액세스 방식으로 DB 버퍼캐시를 경유해서 읽음.
  - 추가적인 `래치 경쟁`과 `캐시버퍼 체인 스캔` 과정을 거침. 버퍼캐시에서 못 찾을 경우 `DISK IO`도 발생


- 소트 머지 조인은 PGA에서 수행하므로 래치경쟁에서 비교적 자유로움
  - 소트 머지 조인도 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유하고, 인덱스를 사용하기도 함.
  이때는 버퍼캐시 탐색 비용, 랜덤 액세스 비용을 피할 수 없음


### 4.2.4 소트 머지 조인의 주 용도

- 조인 조건이 `=` 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 카테시안(크로스) 조인


### 4.2.5 소트 머지 조인 제어하기

`SELECT /*+ ordered use_merge(c) *`


### 4.2.6 소트 머지 조인 특징 요약
소트 부하만 감수하면, 건건이 버퍼캐시를 경유하는 NL조인보다 빠르다
NL조인과 달리 인덱스 유무의 영향을 받지 않는다.

> 250217(월) 255p ~ 281p

## 4.3 해시 조인

`소트 머지 조인`과 `해시조인`은 인덱스를 이용하지 않음
→ 대량 데이터 조인에 NL조인보다 빠르고, 일정한 성능을 보임 

해시조인은 테이블을 정렬하는 부하도 없음

### 4.3.1 기본 메커니즘

마찬가지로 두 단계로 진행됨

1. Build 단계
   - 작은 쪽 테이블 (Build Input)을 읽어 헤시 테이블(해시 맵)을 생성한다.
   - ex) 사원번호로 PGA의 Hash Area 혹은 Temp Tablespace에 해시 테이블을 생성
2. Probe 단계
   - 큰 쪽 테이블 (Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.
   - ex) 최종주문금액 조건을 만족하는 로우 중에서 관리사원번호로 해쉬조인을 실시한다.

힌트 : `use_hash(a b)`


### 4.3.2 해시 조인이 빠른 이유

소트 머지 조인이 빠른 이유와 같음
- PGA에서 진행, 래치 경쟁 X

해시조인도 Build Input, Probe Input을 각 테이블에서 읽을 때는 DB 버퍼캐시를 경유하고, 인덱스를 사용하기도 한다.

- 해시테이블에는 조인 키값만이 아닌 쿼리에 사용되는 모든 컬럼이 포함된다.


- 소트 머지 조인의 준비 단계 : 양 테이블을 조인 키 값으로 정렬. 이 때 Temp Tablespace로 넘어갈 가능성이 높음
- 해시 조인의 준비 단계 : 작은 쪽 테이블을 읽어서 해시 테이블 생성. Temp Tablespace로 넘어가더라도 상대적으로 부하 적음
  - Temp Tablespace로 넘어가지 않고 PGA의 해시 공간에서 처리하는 것을 `인메모리 해시 조인`이라 칭함


### 4.3.3 대용량 Build Input 처리

양 쪽 테이블이 모두 대용량이라 인메모리 해시 조인이 불가능하다면
→ 분할 정복방식을 사용

1. 파티션 단계
   - 양쪽 집합 **(조인 이외 조건절을 만족하는 레코드)** 의 조인컬럼으로 얻은 해시값들을 바탕으로 동적으로 파티셔닝
     - 독립적으로 처리 가능한 여러 서브집합으로 짝이 맞게 분할
   - Temp Tablespace에 저장

2. 조인 단계
   - 각 짝으로 조인 수행
     - 이 때 테이블에 상관없이 작은 쪽이 Build Input, 큰 쪽이 Probe Input
     - Build Input으로 해시 테이블을 만들고, 반대쪽으로 해시테이블 탐색
     
     
### 4.3.4 해시 조인 실행계획 제어

힌트에 ordered없이 use_hash만 사용할 경우 옵티마이저는 조건절에 해당하는 카디널리티가 작은 테이블을 Build Input으로 선택한다.

Build Input을 지정하고 싶다면 ordered 혹은 leading절을 이용한다.
`swap_join_inputs(t)` 구문으로 직접 지정할 수도 있다.

```sql
select /*+ leading(a) use_hash(b) swap_join_inputs(b) */
```


#### 세 개 이상 테이블 해시 조인

- `swap_join_inputs`, `no_swap_join_inputs` 힌트를 이용해 Build Input을 지정하는 방법 기억하기
- 원하는 조인 순서에 따라 leading 힌트에 기술하고, Build Input으로 사용하고 싶은 테이블을 swap_join_inputs에 지정하면 된다.
  - 조인된 결과 집합을 Build Input으로 지정하고 싶다면 `no_swap_join_inputs`로 Probe Input을 지정하면 된다.
  
  
### 4.3.5 조인 메소드 선택 기준

- 일반적인 메소드 선택 기준
  1. 소량 데이터 조인 → NL조인
  2. 대량 데이터 조인 → 해시 조인
  3. 해시조인이 불가능 할 때 (`=`조건으로 조인하지 않을 때) → 소트 머지 조인


- 대량 : NL조인 기준으로 최적화했음에도 랜덤 액세스가 많고 성능이 문제라면 대량

- 해시조인이 매우 빠른 경우가 아니라면 NL조인이 바람직하다.

- 조인방식을 고를 때 NL조인을 먼저 고려해야하는 이유
  - 수행빈도가 높은 쿼리를 해시조인, 소트 머지 조인으로 처리하면 CPU와 메모리에 부담이 너무 커짐


## 4.4 서브쿼리 조인

실무에서는 두세개가 아닌 더 많은 테이블을 조인하기 때문에
서브쿼리 조인에 대한 이해가 있어야 한다.

### 4.4.1 서브 쿼리 변환이 필요한 이유

옵티마이저는 비용을 산출하기 전에
사용자가 제출한 쿼리를 최적화하기 쉽도록 변환

- 서브 쿼리 종류
  - 인라인 뷰
  - 중첩 서브쿼리
  - 스칼라 서브쿼리

### 4.4.2 서브쿼리와 조인

#### 필터 오퍼레이션

- exists에 사용한 서브쿼리문에 `/*+ no_unnest */` 기술하면 서브쿼리를 풀어내지 않음으로써 필터링을 위해 사용할 수 있다.

- NL조인과 다른점
  - 스킵기능; 메인쿼리와 서브쿼리와 조인된 후에는 break; 서브쿼리의 다음을 계속 이행하지 않고, 메인쿼리의 다음 로우를 처리한다.
  - 캐싱기능; 서브쿼리에 입력하는 값에 따른 결과값을 캐싱하여 반복된 값에 대한 답을 바로 도출


- 서브쿼리는 항상 메인 쿼리에 종속됨. 메인쿼리가 드라이빙 집합


#### 서브쿼리 unnesting

계층구조를 풀어내고 flat하게 만들어줌

unnesting되면 `필터` 방식을 사용할순 없지만
조인문처럼 다양한 최적화 기법 사용 가능

- `nl 세미 조인` : nl조인과 같은 프로세스지만, 조인에 성공하면 진행을 멈추고 다음 메인 쿼리를 진행

이 외에도 다양한 기법이 활용될 수 있다는 장점

```sql
-- 서브쿼리를 메인쿼리보다 먼저 처리함
select /*+ leading(거래@subq) use_nl(c)*/ *
from table_c c
where exists (
	select ~
    from 거래
    where c.col_a = 거래.col_a
    	and ~
)
```

- `rownum<:n`으로 출력 수를 제한하는 방법을 서브쿼리에 사용하면 성능이 떨어질 수도 있다.
  - ex) exists에 사용하는 서브쿼리문에 rownum<=1 사용

rownum 조건은 여러 힌트를 작동하지 못하게함 (unnest 등)


#### 서브쿼리 pushing

일반적으로 unnest되지 않은 서브쿼리는 보통 필터 방식으로, 맨 마지막 순서로 처리됨

- 309p의 실행계획
  - 서브쿼리에서 필터링하는 데이터의 양이 상당하다.
  필터링을 먼저 하여 조인되는 양을 줄일 수 있다면 좋은 경우


- `서브쿼리 Pushing` : 서브쿼리를 실행계획 안쪽으로 밀어넣음. 먼저 처리되게함. 힌트 : `push_subq`
  - **unnest되지 않은 서브쿼리에만 작동함**. 따라서 `no_unnest`와 같이 사용하는 것이 바람직
  

### 4.4.3 뷰(view)와 조인

- 최적화 단위는 기본적으로 쿼리 블록


- 311p 뷰와 조인하는 쿼리
  - 뷰 밖에선 전월 데이터만 읽는데, 뷰는 이미 모든 데이터를 읽는다.
  → `merge` 힌트를 이용해 메인 쿼리와 합침. @ 이 때 변하는 실행계획 **확인하기** @
  
  - merge하여 수정된 내용으론 `nl join`방식을 사용하여 비효율은 줄었지만,
  전체를 group by 한 후 출력할 수 있기 때문에 부분범위 처리는 불가능하다.
  → 이런 경우 보통 `hash 조인`이 빠름

#### 조인 조건 pushdown

메인 쿼리의 조인 조건절 값을 뷰 안으로 밀어넣음
힌트 : `push_pred`

위 힌트를 써서 실행계획에 `VIEW PUSHED PREDICATE`가 발생한다면
기술된 쿼리의 같은 경우 당월 거래 데이터만 조회하고, 중간에 멈출 수도 있다. (부분범위 처리가 가능하다)

실행계획만 보면 고객데이터와 별개로 group by까지 수행한 것으로 보일 수 있지만,
조인조건이 pushdown됐으므로 `group by 조인조건`을 수행하여 부분범위처리가 가능한 것
`push down predicate` 라는 실행계획에 주의


- `Lateral`, `Outer apply`, `Cross Apply` 구문으로 인라인 뷰를 대체하면, 인라인 뷰에서 다른 테이블의 컬럼을 참조하고 조인할 수 있다. 
단 조인 조건 pushdown이 잘 작동하므로 대체할 정도는 아니고, 코드가 혼란해질 수 있다.

> 250218(화) 282p ~ 316p

### 4.4.4 스칼라 서브쿼리 조인

> 250219(수) 317p ~ p