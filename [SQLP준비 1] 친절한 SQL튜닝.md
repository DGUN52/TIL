# 친절한 SQL튜닝



## 1.1 SQL파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
- **구조적, 집합적, 선언적** 질의 언어

### 1.1.2 SQL 최적화
- 1) SQL파싱 (파서가 수행)
  - 파싱 트리 생성
  - 문법 체크
  - SEMANTIC 체크 : 테이블/컬럼 잘못되게 참조했는지, 오브젝트 권한 보유 여부
- 2) SQL 최적화 (옵티마이저가 수행)
  - 메타데이터를 바탕으로 다양한 실행경로를 생성/비교, 최종 선택
- 3) 로우 소스 생성
  - 실제 실행 가능한 코드/프로시저로 생성
  
### 1.1.3 SQL옵티마이저

1) 실행계획들 찾아냄
2) 데이터 딕셔너리의 메타데이터를 통해 예상비용 산정
3) 최저 비용의 실행계획 수행


### 1.1.4 실행계획과 비용
- 실행계획(Explain)

- 인덱스 힌트
  ```sql
  select /*+ index(t t_x02) */ 
  	a
  	, b
  	, c
  from 
  	t
  where 
  	deptno = 10 
  	and no = 1
  ;
  ```
  

### 1.1.5 옵티마이저 힌트

```sql
/*+ index(t t_x01) */ 

! 가능
/*+ index(t, t_x01) index(t2, t2_x01) */  

! 불가능 (힌트 사이에 반점)
/*+ index(t t_x01), index(t2, t2_x01) */

! 불가능 (테이블에 별칭 지정 시 힌트에도 별칭 지정)
select /*+ index(tmp t_x01) */ *
from tmp t
```

#### 인덱스 힌트 목록
- 최적화 목표
  - ALL_ROWS
  - FIRST_ROWS(N)
- 액세스 방식
  - FULL
  - INDEX
  - INDEX_DESC
  - INDEX_FFS
  - INDEX_SS
- 조인 순서
  - ORDERED
  - LEADING
  - SWAP_JOIN_INPUTS
- 조인 방식
  - USE_NL
  - USE_MERGE
  - USE_HASH
  - NL_SJ
  - MERGE_SJ
  - HASH_SJ
- 서브쿼리 팩토링
  - MATERIALIZE
  - INLINE
- 쿼리 변환
  - MERGE
  - NO_MERGE
  - UNNEST
  - NO_UNNEST
  - PUSH_PRED
  - NO_PUSH_PRED
  - USE_CONCAT
  - NO_EXPAND
- 병렬 처리
  - PARALLEL
  - PARALLEL_INDEX
  - PQ_DISTRIBUTE
- 기타
  - APPEND
  - DRIVING_SITE
  - PUSH_SUBQ
  - NO_PUSH_SUBQ
  
## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트 파싱 vs 하드 파싱
- 최적화를 거친 다음 생성된 프로시저는 `라이브러리 캐시` (SGA 내부 요소)에 저장해된다.
- 이미 있는 실행계획을 가져오는 것을 `소프트파싱` (바로 실행 단계로 넘어감)
- 찾지 못하고 최적화, 로우 소스 생성까지 다 하는 것을 `하드 파싱`


- 옵티마이저가 사용하는 메타데이터 종류
  - 테이블, 컬럼, 인덱스 구조
  - 오브젝트 통계
  - 시스템 통계
  - 옵티마이저 관련 파라미터
  
### 1.2.2 바인드 변수의 중요성
- preparedStatements를 사용하면 다양한 입력변수에 일일히 하드파싱 하지 않고 프로시저형식으로 재사용된다.

> 250206(목) 17p ~ 35p


## 1.3 데이터 저장 구조 및 I/O 메커니즘

### 1.3.1 SQL이 느린 이유
DISK IO때문


### 1.3.2 데이터베이스 저장 구조
- 테이블 스페이스 > 세그먼트(오브젝트) > 익스텐트(확장 단위, 연속된 블록 집합) > 블록(데이터 접근 단위) > 로우
- 하나의 데이터파일은 여러 테이블의 익스텐트를 저장한다.
= 한 테이블의 익스텐트들은 여러 데이터파일에 위치할 수 있다.

### 1.3.3 블록 단위 IO
데이터는 블록 단위로 RW됨

### 1.3.4 시퀀셜 액세스 VS 랜덤 액세스
- 시퀀셜 액세스 : 익스텐트 맵에서 익어야 할 익스텐트 목록을 얻고
각 익스텐트를 순차적으로 읽으면 FULL TABLE SCAN임

### 1.3.5 논리적IO vs 물리적IO
- 논리적 IO : DB 버퍼캐시 + DIRECT PATH I/O(캐시 경유 안함)
- 물리적 IO : 디스크 READ/WRITE(캐시에 적재)


- 총 블록 IO : 논리적 IO


- 버퍼 캐시 히트율(BCHR)
 = 캐시 HIT / 총 IO
 = (논리IO - 물리 IO) / 논리 IO
 = 1 - ( 물리IO / 논리 IO )

- 성능에 지장을 주는 것은 물리 IO
물리 IO를 줄이려면 총 IO(논리 IO)를 줄여야한다.

- BCHR은 같은 블록을 비효율적으로 반복적으로 읽으도 높아진다.

### 1.3.6 Single Block IO vs Multi Block IO
- 메모리(캐시)에 블록을 한개/여러개씩 하는지
- SINGLE : 인덱스 스캔
- MULTI : 풀스캔


- 여러 블록을 1MB단위로 적재를 한다해도 익스텐트 단위로 읽는다.(IO 개별 양이 1MB 이하일 수 있다)
- MULTI BLOCK으로 여러 익스텐트를 I/O하는 와중에 캐싱데이터가 있으면 그 전까지 읽어야하는 디스크IO를 SINGLE로 처리할 수도 있다.


### 1.3.7 TABLE FULL SCAN vs INDEX RANGE SCAN
인덱스 스캔은 소량의 데이터를 구할 때 효율적이다.
다량 데이터는 풀스캔이 효율적이다


### 1.3.8 캐시 탐색 메커니즘

- 해시 함수로 구현된 경우 해시 체인에서 찾고자하는 블록의 버퍼 헤더를 찾고 이를 이용해 버퍼 블록을 액세스한다.
- 해당하는 해시 체인에서 못 찾을 경우 다른 해시 체인을 탐색할 필요 없음
- 해시 체인에 동시에 접근할 경우 정합성 문제가 있기 때문에 액세스를 직렬화한다. 이 메커니즘을 LATCH라 함


- 이런 직렬화 메커니즘에 의해 버퍼 LOCK 경합이 발생할 수 있기 때문에 논리IO자체를 줄여야한다.


> 250208(토) 36p ~ 66p


## 2.1 인덱스 구조 및 탐색

## 2.1.1 미리 보는 인덱스 튜닝


> 250208(토) 69p ~ p
