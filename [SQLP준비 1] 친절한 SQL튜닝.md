# 친절한 SQL튜닝



## 1.1 SQL파싱과 최적화
### 1.1.1 구조적, 집합적, 선언적 질의 언어
- **구조적, 집합적, 선언적** 질의 언어

### 1.1.2 SQL 최적화
- 1) SQL파싱 (파서가 수행)
  - 파싱 트리 생성
  - 문법 체크
  - SEMANTIC 체크 : 테이블/컬럼 잘못되게 참조했는지, 오브젝트 권한 보유 여부
- 2) SQL 최적화 (옵티마이저가 수행)
  - 메타데이터를 바탕으로 다양한 실행경로를 생성/비교, 최종 선택
- 3) 로우 소스 생성
  - 실제 실행 가능한 코드/프로시저로 생성
  
### 1.1.3 SQL옵티마이저

1) 실행계획들 찾아냄
2) 데이터 딕셔너리의 메타데이터를 통해 예상비용 산정
3) 최저 비용의 실행계획 수행


### 1.1.4 실행계획과 비용
- 실행계획(Explain)

- 인덱스 힌트
  ```sql
  select /*+ index(t t_x02) */ 
  	a
  	, b
  	, c
  from 
  	t
  where 
  	deptno = 10 
  	and no = 1
  ;
  ```
  

### 1.1.5 옵티마이저 힌트

```sql
/*+ index(t t_x01) */ 

! 가능
/*+ index(t, t_x01) index(t2, t2_x01) */  

! 불가능 (힌트 사이에 반점)
/*+ index(t t_x01), index(t2, t2_x01) */

! 불가능 (테이블에 별칭 지정 시 힌트에도 별칭 지정)
select /*+ index(tmp t_x01) */ *
from tmp t
```

#### 인덱스 힌트 목록
- 최적화 목표
  - ALL_ROWS
  - FIRST_ROWS(N)
- 액세스 방식
  - FULL
  - INDEX
  - INDEX_DESC
  - INDEX_FFS
  - INDEX_SS
- 조인 순서
  - ORDERED
  - LEADING
  - SWAP_JOIN_INPUTS
- 조인 방식
  - USE_NL
  - USE_MERGE
  - USE_HASH
  - NL_SJ
  - MERGE_SJ
  - HASH_SJ
- 서브쿼리 팩토링
  - MATERIALIZE
  - INLINE
- 쿼리 변환
  - MERGE
  - NO_MERGE
  - UNNEST
  - NO_UNNEST
  - PUSH_PRED
  - NO_PUSH_PRED
  - USE_CONCAT
  - NO_EXPAND
- 병렬 처리
  - PARALLEL
  - PARALLEL_INDEX
  - PQ_DISTRIBUTE
- 기타
  - APPEND
  - DRIVING_SITE
  - PUSH_SUBQ
  - NO_PUSH_SUBQ
  
## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트 파싱 vs 하드 파싱
- 최적화를 거친 다음 생성된 프로시저는 `라이브러리 캐시` (SGA 내부 요소)에 저장해된다.
- 이미 있는 실행계획을 가져오는 것을 `소프트파싱` (바로 실행 단계로 넘어감)
- 찾지 못하고 최적화, 로우 소스 생성까지 다 하는 것을 `하드 파싱`


- 옵티마이저가 사용하는 메타데이터 종류
  - 테이블, 컬럼, 인덱스 구조
  - 오브젝트 통계
  - 시스템 통계
  - 옵티마이저 관련 파라미터
  
### 1.2.2 바인드 변수의 중요성
- preparedStatements를 사용하면 다양한 입력변수에 일일히 하드파싱 하지 않고 프로시저형식으로 재사용된다.

> 250206(목) 17p ~ 35p


## 1.3 데이터 저장 구조 및 I/O 메커니즘

### 1.3.1 SQL이 느린 이유
DISK IO때문


### 1.3.2 데이터베이스 저장 구조
- 테이블 스페이스 > 세그먼트(오브젝트) > 익스텐트(확장 단위, 연속된 블록 집합) > 블록(데이터 접근 단위) > 로우
- 하나의 데이터파일은 여러 테이블의 익스텐트를 저장한다.
= 한 테이블의 익스텐트들은 여러 데이터파일에 위치할 수 있다.

### 1.3.3 블록 단위 IO
데이터는 블록 단위로 RW됨

### 1.3.4 시퀀셜 액세스 VS 랜덤 액세스
- 시퀀셜 액세스 : 익스텐트 맵에서 익어야 할 익스텐트 목록을 얻고
각 익스텐트를 순차적으로 읽으면 FULL TABLE SCAN임

### 1.3.5 논리적IO vs 물리적IO
- 논리적 IO : DB 버퍼캐시 + DIRECT PATH I/O(캐시 경유 안함)
- 물리적 IO : 디스크 READ/WRITE(캐시에 적재)


- 총 블록 IO : 논리적 IO


- 버퍼 캐시 히트율(BCHR)
 = 캐시 HIT / 총 IO
 = (논리IO - 물리 IO) / 논리 IO
 = 1 - ( 물리IO / 논리 IO )

- 성능에 지장을 주는 것은 물리 IO
물리 IO를 줄이려면 총 IO(논리 IO)를 줄여야한다.

- BCHR은 같은 블록을 비효율적으로 반복적으로 읽으도 높아진다.

### 1.3.6 Single Block IO vs Multi Block IO
- 메모리(캐시)에 블록을 한개/여러개씩 하는지
- SINGLE : 인덱스 스캔
- MULTI : 풀스캔


- 여러 블록을 1MB단위로 적재를 한다해도 익스텐트 단위로 읽는다.(IO 개별 양이 1MB 이하일 수 있다)
- MULTI BLOCK으로 여러 익스텐트를 I/O하는 와중에 캐싱데이터가 있으면 그 전까지 읽어야하는 디스크IO를 SINGLE로 처리할 수도 있다.


### 1.3.7 TABLE FULL SCAN vs INDEX RANGE SCAN
인덱스 스캔은 소량의 데이터를 구할 때 효율적이다.
다량 데이터는 풀스캔이 효율적이다


### 1.3.8 캐시 탐색 메커니즘

- 해시 함수로 구현된 경우 해시 체인에서 찾고자하는 블록의 버퍼 헤더를 찾고 이를 이용해 버퍼 블록을 액세스한다.
- 해당하는 해시 체인에서 못 찾을 경우 다른 해시 체인을 탐색할 필요 없음
- 해시 체인에 동시에 접근할 경우 정합성 문제가 있기 때문에 액세스를 직렬화한다. 이 메커니즘을 LATCH라 함


- 이런 직렬화 메커니즘에 의해 버퍼 LOCK 경합이 발생할 수 있기 때문에 논리IO자체를 줄여야한다.


> 250208(토) 36p ~ 66p


## 2.1 인덱스 구조 및 탐색

인덱스 탐색은 수직적 탐색, 수평적 탐색으로 이루어짐

### 2.1.1 미리 보는 인덱스 튜닝

SQL튜닝은 랜덤I/O를 줄이는 것이 목표이다.

### 2.1.2 인덱스 구조

- B* tree 인덱스 - 루트 블록 - 브랜치 블록 - 리프 블록
- LMC = left most child, 인덱스 가장 좌측의 데이터


- ROWID = 데이터 블록 주소 + 로우 번호
- DBA (data block address) = 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터파일 내에서 부여된 순번
- 로우 번호 : 블록 내 순번


### 2.1.3 인덱스 수직 탐색
- 인덱스 스캔 시작 지점을 탐색
- 리프블록부터 다음 과정을 거친다.
  - 찾는 데이터보다 인덱스데이터가 크다면 좌측, 찾는 데이터가 더 크다면 우측으로 이동
  - 찾는 데이터와 인덱스 데이터가 일치하면, 일치하는 인덱스의 바로 전 데이터가 가리키는 블록으로 이동하여 탐색 시작
  
### 2.1.4 인덱스 수평 탐색
- 인덱스의 리프 블록에서 스캔 시작 지점을 찾았으면 만족하지 않는 값이 나올 때 까지 탐색 시작(데이터 탐색)
  - 탐색해서 얻은 ROWID로 테이블에 액세스
  
### 2.1.5 결합 인덱스 구조와 탐색
- 결합 인덱스의 순서를 바꾸어도 **=** 조건일 경우에는 읽는 블록 수가 같다.
- B* Tree에서 인덱스 트리의 높이는 균일하다. (Balanced)


## 2.2 인덱스 기본 사용법

- index range scan

### 2.2.1 인덱스를 사용한다는 것

- 인덱스 선두 컬럼을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
  - 정상적 사용 : 인덱스 리프 블록의 일부만 있는 index range scan
  - 인덱스 선두 컬럼이 가공될 경우 : 인덱스 시작점, 끝점을 파악할 수 없음
    - 인덱스 리프 블록 전체 스캔(index full scan) 수행

```sql
ex)
where substr(bday, 5, 2) = '05'
where nvl(주문수량, 0) < 100
where 업체명 like '%대한%'
where A=10 or B='abcd'
```

- OR Expansion : or 조건식을 union all로 처리해 index range scan을 사용하게 하는 옵티마이저 기법 (`/*+ use concat*/` 사용)
- IN-List Iterator : in 조건식의 개수만큼 index range scan 반복


### 2.2.3 더 중요한 인덱스 사용 조건

- 인덱스 컬럼이 가공된 경우 필터링 역할을 수행하지 못한다.
- SQL 튜닝은 총 읽는 수 자체를 줄여야함

### 2.2.4 인덱스를 이용한 소트 연산 생략

- order by 컬럼이 인덱스 컬럼에 포함 될 경우 소트 연산이 생략된다.

### 2.2.5 order by 절에서 컬럼 가공

- order by/ select 절에서 컬럼을 가공하여 인덱스를 사용하지 못할 수 있다.
```sql
아래와 같은 경우 sort 생략 불가
select TO_CHAR(주문번호, ~)
from A
~
order by A

이 경우 TO_CHAR로 가공된 데이터에 대해  정렬을 수행하므로 소트 생략 불가
```

### 2.2.6 SELECT - LIST 에서 컬럼 가공
```sql
-- sort 생략 불가 (데이터형 변경한 후 MAX값 찾음)
SELECT MAX(TO_NUMBER(변경순번))

-- sort 생략 가능
SELECT TO_NUMBER(MAX(변경순번))
```

### 2.2.7 자동 형변환
```sql
SELECT * FROM 고객
WHERE 생년월일 = 19870605
```
위 쿼리는 `생년월일` 컬럼을 숫자로 자동 형변환하여 사용하기 때문에 INDEX RANGE SCAN 불가
`기념일 LIKE '%1987&'` 이 경우 `기념일` 컬럼이 문자형으로 자동 변환됨

등 자동 형변환에 의해 여러 품질저하를 일으킬 수 있다.



## 2.3 인덱스 확장기능 사용법

### 2.3.1 Index Range Scan
- 수직 탐색 후 필요한 만큼만 수평탐색


### 2.3.2 Index Full Scan
- 수직탐색 없이 Index 리프 블록 전체 스캔

```sql
create index emp_x01 on emp (ename, sal);

select * from emp
where sal > 2000
;
```
위 경우에 index full scan 발생

index full scan이라도 소량의 데이터만 원하는 경우 full scan보다 유리
대량의 데이터가 해당되는 경우 Table Full Scan보다 불리


### 2.3.3 Index Unique Scan
- 수직 탐색만으로 데이터 스캔
  - Unique 인덱스를 = 조건으로 탐색할 경우
- unique 인덱스라도 범위조건으로 검색할 경우 Index Range Scan 발생


### 2.3.4 Index Skip Scan
```sql
-- 인덱스 구성 (성별, 연봉)
select /*+ index_ss(emp emp_idx) */ col_a
from emp
where 연봉 between 2000 and 4000
...
```
- 오라클 9i에 도입
- 선두 컬럼의 고유값이 적고(성별) 후행 컬럼의 고유값(연봉)이 많을 경우 유용


- 선두 컬럼들이 쿼리에 없을 때도 사용 가능

- 선두 컬럼들이 범위검색(부등호, between, like)일 때도 사용 가능


### 2.3.5 Index Fast Full Scan
```sql
select /*+ index_ffs(emp emp_idx) */
```
- 인덱스 전체를 Multiblock IO방식으로 스캔
  - 물리적 순서대로 스캔 (index full scan 은 논리적 순서대로 스캔)
- 결과집합이 키에 따라 정렬되지 않음
- 쿼리에 사용된 컬럼이 모두 인덱스에 포함돼있어야함
- 인덱스가 파티션돼있지 않아도 병렬쿼리가 가능(Direct Path IO 사용됨)


### 2.3.6 Index Range Scan Descending
- Index Range Scan을 내림차순 실행함
- order by ~ desc절이 있을 때, MAX(col_a) 항목이 있을 때 발생됨



> 250209(일) 69p ~ 125p


# 3. 인덱스 튜닝

## 3.1 테이블 액세스 최소화

### 3.1.1 테이블 랜덤 액세스
- ROWID는 포인터, 물리적 주소가 아닌 논리적 주소임


- 버퍼캐시 탐색 : DBA → 해시함수 → 해시체인 → 버퍼 헤더 → 버퍼 블록
- 인덱스 탐색 : 리프블록의 ROWID → DBA정보 획득
- Full Scan : 익스텐트 맵 → 읽을 블록들의 DBA정보 획득 → 병렬 풀 스캔


모든 데이터가 캐싱돼있어도 매번 해싱, 래치 획득 과정을 반복해야함
→ 인덱스 ROWID를 이용한 액세스는 생각보단 고비용 구조


### 3.1.2 인덱스 클러스터링 팩터

- CF. 군집성 계수 : 같은 값을 갖는 데이터가 모여있는 정도
  - CF가 높다면 찾고자 하는 데이터양에 비해 블록 IO가 적게 발생한다.
  - ?인덱스 데이터는 랜덤 블록 IO인데 모여있다고 해서 액세스 수가 줄어드나?
  	- 버퍼 pinning : 테이블 블록에 접근해서 데이터를 찾았을 때, 포인터를 바로 해제하지 않고 유지하는 기법. 이를 재사용할 수 있다.


### 3.1.3 인덱스 손익분기점

- 인덱스 스캔 시 읽어야할 데이터가 많아져서 Table Full Scan보다 속도가 느려지는 분기점
- CF가 나쁘면(BCHR까지 낮으면) 1~5%, CF가 좋으면 5~20%, CF가 아주 좋으면(인위적 인덱스 정렬) 90%까지
- 테이블의 크기가 10만건 처럼 낮으면 또 손익분기점이 높아지고,
테이블의 크기가 1000만건 처럼 높으면 또 손익분기점이 낮아진다.


- OLTP 프로그램 : 주로 인덱스+NL조인 사용(소량 데이터의 빠른 조회)
- 배치 프로그램 : FULL스캔+HASH조인 사용(대량 데이터의 빠른 처리)


- 파티셔닝을 통해 Full Scan의 부담을 줄일 수 있다.


### 3.1.4 인덱스 컬럼 추가

- 튜닝에 있어서 흔히 사용되는 기법

### 3.1.5 인덱스만 읽고 처리

- Covered 쿼리 : 인덱스만 읽어서 처리하는 쿼리
  - Covered 인덱스 : 그 쿼리에 사용된 인덱스

```sql
SELECT 부서번호, SUM(수량)
FROM 판매집계
WHERE 부서번호 LIKE '12%'
GROUP BY 부서번호;
```
이 쿼리에서 부서번호 단일 컬럼 인덱스를 사용할 때,
필터에 의해 버려지는 데이터가 없으므로 비효율은 없다.

단 데이터량 자체가 많다면 오래걸릴 수 있는데,
`수량`컬럼까지 인덱스에 추가하여 테이블 액세스 자체를 없애면 속도가 상승할 수 있다.


- Include 인덱스 : 인덱스 키 외에 컬럼을 추가적으로 리프 레벨에 저장하는 인덱스. 순전히 테이블 랜덤 액세스를 줄이는 용도


### 3.1.6 인덱스 구조 테이블

- Index Organied Table (IOT) : 인덱스 구조로 생성된 테이블. (Clustered Index)
  - 물리적으로 정렬되어 입력되기 때문에 랜덤 액세스가 아닌 시퀀셜 액세스로 읽는다.
  - 입력시기와 조회시기가 상이할 때 IOT로 구성해주면 CF 군집도를 높여서 블록IO 발생 수를 줄일 수 있다.
  ex) 매일 발생하는 실적 데이터를 사번으로 조회할 때, 일반적으론 군집도가 매우 떨어지지만 사번을 선두컬럼으로 한 IOT로 구성하면 읽는 블록 수가 급격히 감소한다.
  
  
### 3.1.7 클러스터 테이블
- 인덱스 클러스터 테이블 : 키 값이 같은 레코드를 한 블록에 저장. 블록 범위를 벗어날 경우 체인 생성
  - cluster 생성 → 클러스터 인덱스 생성 → 테이블 생성, 데이터 입력 (테이블 삽입 전에 인덱스 생성되어야함)
  - 데이터를 클러스터 인덱스 키 값에 따라 같은 블록에 저장할 뿐 블록 내에서 정렬하진 않음(iot와 차이점)
  따라서 인덱스와 레코드는 1:M의 관계이고 키는 항상 unique.
  - 랜덤 액세스는 클러스터를 찾을 때 값 하나당 한 번 밖에 발생하지 않음(비효율 없음)
  - 다중 테이블 클러스터 : 여러 테이블을 한 블록에 저장(일반 테이블은 블록 공유 불가능)


- 해쉬 클러스터 테이블 : 인덱스 대신 해시 알고리즘으로 키 사용

> 250210(월) 129p ~ 158p

## 3.2 부분범위 처리 활용

> 250211(화) 159p ~ p